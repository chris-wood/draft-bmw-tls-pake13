{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-01-07T00:17:43.854562+00:00",
  "repo": "chris-wood/draft-bmw-tls-pake13",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOM83jm86dcuFH",
      "title": "Discussion regarding PAKE draft",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/issues/3",
      "state": "CLOSED",
      "author": "BjoernMHaase",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\r\n\r\n\r\n>Hi Chris, \r\n>\r\n>thank you for again starting an effort for having PAKE integrated within TLS. I appreciate that.\r\n>\r\n>Hi Laura and Samir,\r\n>\r\n>with this mail I\u2019d like to establish the contact to you and offer support with getting things further here.\r\n>\r\n>\r\n>I have just had a very first look at your draft when sitting in some meetings in IETF121. I am having the following preliminary feedback:\r\n>\r\n>- I think that we will have to clarify on what client and server are to have included in their respective messages. I see the issue with >your draft that while the client will be able to include its client identity it might not be having a server identity value available when >starting the protocol. I.e. the client will not be able in practice to provide the structure that you currently specify:\r\n>\r\n>  struct {\r\n>       NamedPAKE   named_pake;\r\n>       opaque      client_identity<0..2^16-1>;\r\n>       opaque      server_identity<0..2^16-1>;\r\n>       opaque      pake_message<1..2^16-1>;\r\n>   } PAKEShare;\r\n>\r\n>Instead I see the need that the mechanism is as follows: The client transmits a client identity field which *may* be empty. The server >includes a server identity field which also *may* be empty.\r\n \r\nThis is exactly what the draft specifies: the client and server identities are optional values on the wire. If they are present for the application, they are included, otherwise they are not. \r\n\r\n>Similarly to the certificate chain validation in a certificate-based authentication protocol we would be having application hooks on >both sides which get the respective remote identity fields and accept or reject a connection request. Probably it would be helpful to >integrate an image on how the TLS core component interfaces with a PAKE software module outside of the TLS core.\r\n> \r\nThis is also specified in the draft, in that the server chooses its password registration record based on the ClientHello PAKE information. If a registration record exists, it attempts to use it for authentication. Otherwise, it does not. \r\n\r\n>- We should be clarifying what the PAKE algorithm specifier named_pake would be including. For symmetric PAKEs there might be >the option to have named_pake specifying the algorithm family (e.g. CPace or SPAKE2) and have a separate specification of the >cipher suite (e.g. group) to be used. I think that for augemented PAKE we will have to make the named_pake ID specify both, the >protocol-type and the cipher suite set used for running the PAKE protocol. This will be necessary because the actual password >verifiers stored by the server will depend not only on the protocol type but also on the cipher suites.\r\n\r\n>My suggestion would be to clarify this property in the draft and to make the named_pake number bundle together both, cipher suite >and protocol type together also for balanced PAKE.\r\n \r\nThis is already specified. The named_pake fully specifies the protocol, e.g., for SPAKE2PLUS_V1 fully specifies the group, hash function, KDF, and MAC algorithms to be used. It is expected that other named_pake values do the same. \r\n\r\n>\u2026. \r\n>\r\n>As a rough idea which will become relevant when drawing the interface image with the message flow between the PAKE module at >the client and at the server and the TLS core will be how to deal with the explicit key confirmation messages. In CPace we have made >a lot of effort for neat integration into TLS by explicitly keeping the key confirmation rounds separate from the PAKE protocol (and >leave it to TLS in the final two messages). This will not be the case for other PAKE constructions.\r\n \r\nIndeed, not every PAKE will be as easy to integrate as CPace or SPAKE2+, but we can cross that bridge when the time comes. If, for example, a PAKE protocol requires its own key confirmation (and cannot use the TLS Finished messages), then that named_pake would have to add a round trip to TLS. While this is undesirable, it\u2019s also not a dealbreaker.\r\n \r\nBest,\r\nChris\r\n\r\n>\u2026\r\n>\r\n>Yours,\r\n>\r\n>Bj\u00f6rn,\r\n\r\n\r\n\r\nP.S.: I hope that you will be accepting such prelimary feedback. Please tell me if you happen to feel spammed with preliminary thoughts like the ones above which have not be thought through to all details and consequences yet. In this case I will try to give you a more comprehensive feedback and not rough ideas as above in the future. \r\nMit freundlichen Gr\u00fc\u00dfen | Best Regards \r\nDr. Bj\u00f6rn Haase \r\n",
      "createdAt": "2024-11-07T16:32:10Z",
      "updatedAt": "2024-12-02T20:59:39Z",
      "closedAt": "2024-12-02T20:59:39Z",
      "comments": [
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "\r\nChris, I think that we should probably be having an image where we detail what interface we are\r\nabout to specify. I fear that otherwise we might be having difficulties regarding the abstraction layer\r\n\r\nIMO we should be talking about the interface between a component that I\u2019d be calling \u201cTLS core\u201d\r\nand components that I\u2019d be calling \u201cPAKE adapter\u201d.\r\n\r\n\r\n```\r\n    Client\r\n    -----------------------  ---------------------|\r\n     Application layer      |                     |   \r\n                            |  Client-side        |\r\n    Password           -->  |  TLS PAKE adapter   |\r\n    Client MD          -->  |                     |\r\n                            |  PAKE MSG 1+2  ->-- |\r\n    Server MD          <--  |  PAKE RSP     -<- | |   \r\n    session ID         <--  |  SK        ->-| | | |     \r\n                            |               | | | |     \r\n                             --------- ===========\r\n    IP address + port  -->  |         |           |\r\n                            |   TCP   |    TLS    |\r\n           downlink <--     |         |   core    |\r\n           uplink    -->    |         |           |\r\n    -----------------------  ---------  ---------\r\n\r\n\r\n    Server\r\n    -----------------------  ---------------------|\r\n     Application layer      |                     |   \r\n                            |  Server-side        |\r\n    Password/Verifier  -->  |  TLS PAKE adapter   |\r\n    Server MD          -->  |                     |\r\n                            |  PAKE MSG 1+2  -<-- |\r\n    Client MD          <--  |  PAKE RSP     ->- | |\r\n    session ID         <--  |  SK        ->-| | | |\r\n                            |               | | | |\r\n                             --------- ===========\r\n    IP address + port  <--  |         |           |\r\n                            |   TCP   |    TLS    |\r\n           downlink  -->    |         |   core    |\r\n           uplink    <--    |         |           |\r\n    -----------------------  ---------  ---------\r\n\r\n\r\n```I.e. even if I believe that we should have the PAKE Adapter code be a part\r\nof the TLS library code, I think that for the purpose of software interfaces\r\nin the code and for the purpose of the specification we should consider\r\nthat the TLS library will have an adapter and a core component on both sides.\r\n\r\nIn the scope of the draft I suggest, that one should be specifying the interface that I highlighted\r\nwith double lines \u201c======\u201d .\r\n\r\nIMO we should be specifying what should be done in the TLS core part\r\nand what has to be provided by the PAKE adapters on both sides and in which\r\nsequence.\r\n\r\nWe then would be having a separate block specifying how the PAKE adapter\r\nblocks shall behave for each of the protocols.\r\n\r\nSaying this, at the ======= interface level we should probably not specify\r\non the actual contents within the PAKE message and response semantics\r\nas this might vary with the actual PAKE protocol in some details.\r\n\r\nOn the interface to the application layer I would distinguish between the concept\r\nof client metadata and server metadata and actual data fields within the PAKE\r\nmessages.\r\n\r\n2.) \r\n\r\nI also think that we should be preparing the option of supplying an interface\r\nbetween the TLS core parts and the TLS PAKE adapter parts for giving\r\nthe TLS core component access to a private/public key pair maintained in\r\nthe TLS PAKE adapter component.\r\n\r\nThe reason is that this would help integrating both OPAQUE and would also\r\nallow for re-using the exact same same interface for FIDO2-based two-factor\r\nauthentication (password + TOKEN).\r\n\r\nI.e. one might prepare the interface \u201c===========\u201d such that it is configurable\r\nwhether client and server shall or shall not activate the certificate-based authentication\r\ncomponent present in today\u2019s TLS core implementations or not.\r\n\r\n\r\nYours,\r\n\r\nBj\u00f6rn\r\n",
          "createdAt": "2024-11-07T16:36:05Z",
          "updatedAt": "2024-11-07T16:36:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "As discussed, this isn't a software architecture document. It's a protocol specification, and I don't think this sort of information helps the reader or implementer in any way. I'm inclined to close this issue with no action.",
          "createdAt": "2024-11-13T14:01:15Z",
          "updatedAt": "2024-11-13T14:01:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "Closing as resolved.",
          "createdAt": "2024-12-02T20:59:39Z",
          "updatedAt": "2024-12-02T20:59:39Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOM83jm86d-G2o",
      "title": "State properties required for PAKES used",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/issues/4",
      "state": "OPEN",
      "author": "menonsamir",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From IETF discussion with @BjoernMHaase and @FrankXL:\r\n\r\nWe should state explicitly what properties a PAKE must have to be eligible for use under this extension (and registered as a NamedPAKE).\r\n\r\nThe main one we've discussed so far is that the PAKE should be compatible with performing key confirmation through the standard TLS 1.3 Finished message.",
      "createdAt": "2024-11-11T20:17:11Z",
      "updatedAt": "2024-12-03T15:29:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Yes I agree. I don't see any property except for the fact that the last PAKE protocol message needs to only include a key confirmation.\r\n\r\nWe also should be having a security consideration paragraph per protocol with an analysis on how the security analysis of the PAKE protocol is covering the security analysis of the interleaved TLS and PAKE construction.",
          "createdAt": "2024-11-12T13:09:51Z",
          "updatedAt": "2024-11-12T13:09:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "I don't know if we need to say anything here, since the extension doesn't dictate how the PAKE updates the TLS key schedule. That's left to each named PAKE. For example, it could be the case that, with SPAKE2+, the TLS key schedule is modified with the key confirmation messages (confirm_P or confirm_V), whereas for with CPace the TLS key schedule could be modified with the output shared secret. (I'm not saying that we should do this for SPAKE2+, but using it as an example to show that the _extension_ isn't imposing requirements on the underlying PAKE in this manner.)\r\n\r\nIf anything, the extension restricts the underlying PAKE to one in which client and server negotiate with identities and PAKE messages, but that covers basically anything.",
          "createdAt": "2024-11-13T14:00:40Z",
          "updatedAt": "2024-11-13T14:00:40Z"
        },
        {
          "author": "WeiGuo-hw",
          "authorAssociation": "NONE",
          "body": "As discussed above, a PAKE should be compatible with performing key confirmation through the standard TLS 1.3 Finished message, so do the key confirmation messages of the PAKE not need to compute individually. \r\nFor example, the TLS 1.3 key schedule can be modified with the intermediate session key ISK for CPace and the shared symmetric secret K_main for SPAKE2+, respectively, and the key confirmation of these PAKEs can be achieved by the TLS 1.3 Finished message without computing the PAKEs\u2019 key confirmation messages individually.",
          "createdAt": "2024-11-21T03:17:33Z",
          "updatedAt": "2024-11-21T08:47:37Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Hi Chris, Yes I agree with you. The aspect that I wanted to highlight is that for any three-message flow PAKE such as SPAKE2+ or OPAQUE you have something \"interleaved\" where you have two protocols. What I meant is that for the specific PAKE instance with three flows some discussion will become important for demonstrating that the way that this interleaving combination is implemented is not security-relevant. IMO this will boil down to a discussion that the exact way how the explictit key confirmation is carried out is not relevant for the PAKE protocol proof and that the specific construction of the TLS \"finished\" message fullfils the requirements needed for the PAKE protocol's security proof. ",
          "createdAt": "2024-11-21T20:36:48Z",
          "updatedAt": "2024-11-21T20:36:48Z"
        },
        {
          "author": "FrankXL",
          "authorAssociation": "NONE",
          "body": "> Hi Chris, Yes I agree with you. The aspect that I wanted to highlight is that for any three-message flow PAKE such as SPAKE2+ or OPAQUE you have something \"interleaved\" where you have two protocols. What I meant is that for the specific PAKE instance with three flows some discussion will become important for demonstrating that the way that this interleaving combination is implemented is not security-relevant. IMO this will boil down to a discussion that the exact way how the explictit key confirmation is carried out is not relevant for the PAKE protocol proof and that the specific construction of the TLS \"finished\" message fullfils the requirements needed for the PAKE protocol's security proof.\r\n\r\nfully agree with this point. But do you think we need more consideration and discussion on other potential interleving combination? ",
          "createdAt": "2024-11-22T01:00:38Z",
          "updatedAt": "2024-11-22T01:00:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "> But do you think we need more consideration and discussion on other potential interleving combination?\r\n\r\nWhy would we consider alternative interleaving mechanisms? Is the current mechanism in some way inadequate?",
          "createdAt": "2024-12-03T15:28:04Z",
          "updatedAt": "2024-12-03T15:28:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "> Hi Chris, Yes I agree with you. The aspect that I wanted to highlight is that for any three-message flow PAKE such as SPAKE2+ or OPAQUE you have something \"interleaved\" where you have two protocols. What I meant is that for the specific PAKE instance with three flows some discussion will become important for demonstrating that the way that this interleaving combination is implemented is not security-relevant. IMO this will boil down to a discussion that the exact way how the explictit key confirmation is carried out is not relevant for the PAKE protocol proof and that the specific construction of the TLS \"finished\" message fullfils the requirements needed for the PAKE protocol's security proof.\r\n\r\nI don't disagree, but you seem to be simply advocating for some text in the security considerations which argues (or points to external arguments) for why replacing the PAKE-specific key confirmation with TLS's key confirmation is sufficient. Is that a correct summary?",
          "createdAt": "2024-12-03T15:29:10Z",
          "updatedAt": "2024-12-03T15:29:10Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOM83jm86d-Jh8",
      "title": "Check interactions with other TLS 1.3 features",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/issues/5",
      "state": "OPEN",
      "author": "menonsamir",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From IETF discussion with @BjoernMHaase, @FrankXL, and @bifurcation:\r\n\r\nWe should ensure there aren't unexpected or confusing interactions between our proposal and other TLS features.\r\n\r\nThe main example brought up so far was resumption tickets. @BjoernMHaase, can you add more detail on your thoughts for those? Thanks!",
      "createdAt": "2024-11-11T20:25:03Z",
      "updatedAt": "2024-11-12T13:10:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Yes. I'd suggest that one digs through all of the subchapters of the full TLS protocol RFC and looks whether we may have to specify something here which may be specific for PAKE protocols.",
          "createdAt": "2024-11-12T13:10:50Z",
          "updatedAt": "2024-11-12T13:10:50Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOM83jm86d-LPB",
      "title": "Clarify client + server identity negotiation",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/issues/6",
      "state": "OPEN",
      "author": "menonsamir",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From IETF discussion with @BjoernMHaase, @FrankXL, and @bifurcation:\r\n\r\nThere were several requests to clarify the purpose of client and server identities, and suggestions on how they should be negotiated.\r\n\r\nSeveral overlapping ideas have been suggested so far:\r\n- Make identities PAKE-specific, so that different PAKEs can treat them differently (@BjoernMHaase)\r\n- It's enough to make identities optional, as the draft currently does (@menonsamir)\r\n- Make the client identity set in the ClientHello, the server identity \u2018requested\u2019 in the ClientHello, and the server + client identity \u2018selected\u2019 in the ServerHello (@bifurcation)\r\n\r\nLet's kick off discussion on this topic here.",
      "createdAt": "2024-11-11T20:29:22Z",
      "updatedAt": "2024-12-03T15:30:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "The client identity used for PAKE may actually also contain information that should be kept confidential, such as user names in case of human users.\r\n\r\nIdeally, we should be preparing the option of having an optional method for encryption of such data. However, I believe that we cannot fully cover that on the level of TLS alone. The way to go here might be to have an alternative approach using the EAP option.\r\n",
          "createdAt": "2024-11-12T13:13:35Z",
          "updatedAt": "2024-11-12T13:13:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "> The client identity used for PAKE may actually also contain information that should be kept confidential, such as user names in case of human users.\r\n\r\nEncrypting the PAKE information is an orthogonal problem, and one that's already solved by ECH, so we don't need to do anything special for that.\r\n\r\nRegarding the identities themselves, I don't think we need to support identity \"negotiation\" as @bifurcation's suggestion seems to hint at. Clients will know what server identity they wish to connect to, as it's the one that was established offline during registration. I think we should keep the identity encoding as-is on the wire, since ultimately it's up to the application to make sense of the identities when authenticating the handshake.",
          "createdAt": "2024-11-13T14:04:19Z",
          "updatedAt": "2024-11-13T14:04:19Z"
        },
        {
          "author": "WeiGuo-hw",
          "authorAssociation": "NONE",
          "body": "The client identity and server identity do not seem to be PAKE-specific, because they are often specified by the application. For example, when a client wishes to connect to a server through this PAKE extension, the server identity is determined and the client needs to choose one identity that he/she wants to login no matter which PAKE algorithm is used in this connection. Therefore, can the client identity and server identity be regarded as common fields for this PAKE extension.",
          "createdAt": "2024-11-21T03:18:56Z",
          "updatedAt": "2024-11-21T03:18:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "> Therefore, can the client identity and server identity be regarded as common fields for this PAKE extension.\r\n\r\nYes, and that's exactly how they are used right now. I'm confused -- are you advocating for a change to the spec? If this issue reduces to encrypting the identities, I'm going to close it since that's addressed by ECH. @BjoernMHaase, thoughts?",
          "createdAt": "2024-12-03T15:30:44Z",
          "updatedAt": "2024-12-03T15:30:44Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOM83jm86eFCPP",
      "title": "Need to consider handshake regarding PBKDF function and transfer of salt values",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/issues/7",
      "state": "OPEN",
      "author": "BjoernMHaase",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In practice the benefit of resilience with respect to server compromise of augmented PAKEs can only be obtained when using memory-hard PBKDF functions which will be parametrized by a workload parameter. In our own environment we denote this combined PBKDF + workload parameter with the greek letter of a small \"sigma\".\r\n\r\nThe draft needs to consider this aspect IMO. Also we should prepare that within one application the parametrization of the workload parameter will be changing over time.\r\n\r\nAs the TLS connection between server and client probably should be expected to be the first interconnection between both parties, we will need to have the handshake regarding the PBKDF and its parametrization to be implemented using the client and server hello messages.\r\n\r\nAs a result I suggest to include a separate set of IANA numbers into the pake-specific payload part. A client may start an attempt with a message for a given PBKDF and parametrization but should be prepared to find a different PBKDF parametrization in the server hello message, such that the appropriate procedure of reaction will be a client hello retry and a second server hello.\r\n\r\nIn principle a PBKDF will be requesting also some SALT value. I'd be in favor of allowing PAKE cipher suites to define whether a salt value is also required. A salt value could be made an optional parameter sent alongside with \"sigma\".",
      "createdAt": "2024-11-12T13:03:07Z",
      "updatedAt": "2024-12-03T15:51:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "I am opposed to this suggestion, for a couple of reasons:\r\n\r\n1. In most cases, clients will know the PBKDF and its parameters to use for a TLS connection, so adding this information to the codepoints doesn't help.\r\n2. In cases where clients do not know this information, they can make a guess at it. If they're wrong, the connection will fail. Alternatively, we could try to recover using some retry flow, as you suggest. However, building in retry mechanics, similar to what ECH supports, is incredibly complex for the sake of an edge case that will almost never exist in practice. I'm pretty firmly against this design.\r\n\r\nI think the right way to solve this problem is for clients to have some way to get the PBKDF parameter set from the server out-of-band, and then have the client use that when establishing the TLS connection. How that's done is very application-specific.",
          "createdAt": "2024-11-13T14:12:58Z",
          "updatedAt": "2024-11-13T14:12:58Z"
        },
        {
          "author": "menonsamir",
          "authorAssociation": "COLLABORATOR",
          "body": "To add to @chris-wood's point here, from a discussion with @baumanl: \r\n\r\nFor augmented PAKEs, only the *client* needs to know the PBKDF used; the server can (in fact, should) be totally oblivious to which PBKDF was used to ultimately generate the registration record. We already make the registration process totally 'out of band' and up to applications. Therefore, since the choice of PBKDF is not a fact that the client and server need to agree on, it does not belong in the codepoint.\r\n\r\nI believe symmetric PAKEs don't have this problem, since they don't need to use PBKDFs in the first place.",
          "createdAt": "2024-11-13T16:42:07Z",
          "updatedAt": "2024-11-13T16:42:07Z"
        },
        {
          "author": "WeiGuo-hw",
          "authorAssociation": "NONE",
          "body": "Hi, Bjoern\r\nIf the salt value is transferred from the server to the client in the ServerHello message during the authentication phase, then the client can only compute its PAKE key exchange information after receiving the salt value from the server, this seems to be incompatible with the standard TLS 1.3 message flows.",
          "createdAt": "2024-11-21T03:21:03Z",
          "updatedAt": "2024-11-21T03:21:03Z"
        },
        {
          "author": "WeiGuo-hw",
          "authorAssociation": "NONE",
          "body": "Hi, Chris\r\nThe HelloRetryRequest mechanism is already supported in standard TLS 1.3 flows in order to improve the probability of successful handshake, since the server may inform the client of one cipher suite supported by both parties through the HRR message and this guarantees that the restarted handshake will be successful. Assume that the client supports five cipher suites, if without the retry mechanism and the first cipher suite is not supported by the server, then the client has to retry the remaining four cipher suites to connect to the server, which will slow the speed of the connection establishment. Therefore, I think this PAKE extension should support the current HRR mechanism in TLS 1.3.",
          "createdAt": "2024-11-21T03:22:10Z",
          "updatedAt": "2024-11-21T03:22:10Z"
        },
        {
          "author": "FrankXL",
          "authorAssociation": "NONE",
          "body": "> Hi, Bjoern If the salt value is transferred from the server to the client in the ServerHello message during the authentication phase, then the client can only compute its PAKE key exchange information after receiving the salt value from the server, this seems to be incompatible with the standard TLS 1.3 message flows.\r\n\r\nSince the salt value needs to be saved in server side and sent to client with the pake connection, but waiting for the server to send the salt value is incompatible with the standard process of TLS 1.3, how do you suggest implementing this feature?",
          "createdAt": "2024-11-21T08:40:03Z",
          "updatedAt": "2024-11-21T08:56:11Z"
        },
        {
          "author": "FrankXL",
          "authorAssociation": "NONE",
          "body": "> Hi, Chris The HelloRetryRequest mechanism is already supported in standard TLS 1.3 flows in order to improve the probability of successful handshake, since the server may inform the client of one cipher suite supported by both parties through the HRR message and this guarantees that the restarted handshake will be successful. Assume that the client supports five cipher suites, if without the retry mechanism and the first cipher suite is not supported by the server, then the client has to retry the remaining four cipher suites to connect to the server, which will slow the speed of the connection establishment. Therefore, I think this PAKE extension should support the current HRR mechanism in TLS 1.3.\r\n\r\nI think two questions need more discussion: 1--Does PBKDF require online negotiation or not? 2 -- If negotiation is required, the clientHello, serverHello, and HRR in the existing TLS 1.3 can be used directly, and I understand that no new complexity is added.",
          "createdAt": "2024-11-21T08:44:54Z",
          "updatedAt": "2024-11-21T08:44:54Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Hi to all of you,\r\n\r\nIn my opinion it is an actual use-case that the client actually might not always know beforehand which PBKDF to use. More specifically, the client might know which PBKDF to use but might *not* know which workload parametrization to actually use for a specific account. \r\n\r\nThe reason is that the requirements regarding PBKDF parametrization should be expected to \"rapidly\" change over time. E.g. I expect that standard organizations will update their recommendations for the workload parameter on a yearly basis. At least this has been common in the last years IIRC. For PBKDF such as argon or scrypt the recommended set of workload parameters is constantly changing with the general decrease in computation cost and increased capabilities of HMI devices.\r\n\r\nAlso documents such as https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf recommend to make the workload parameters depend on the actual application settings and give requirements regarding the minimum salt value length to use for password hashes.\r\n\r\n(Similar documents exists in standards behind a paywall for regulated industries, such as e.g. user databases for sensor calibration control for medicament industries, which declare the recommendations in documents such as the above NIST or similar BSI documents mandatory for a given application setting.)\r\n\r\nAs a result I think that we need to be prepared to be dealing with both\r\n- The fact that a PAKE protocol is used in one of the settings where standards such as in the nist publication above will require applications to use a salt value of when hashing passwords.\r\n- The fact that applications might have to work with varying workload parameters for a given PBKDF over time.\r\n\r\nOn the application side the change of a workload parameter and salt value will be implemented when changing a password or newly registering an account. As a result we should foresee that at least during a transition phase there might be more than one set of workload parameters in one specific server's account database.\r\n\r\nWhen doing this, I don't want to impose too much of this complexity on the TLS integration part. I suggest the following approach for integration in TLS 1.3 without adding too much of complexity:\r\n\r\n- As part of the PAKE specific extension fields (i.e. the component which might differ for different PAKE protocol types) we allow that the initial client hello integrates either \r\n   a) an initial best guess regarding the expected joint \"PBKDF and workload parameters\"  combination and salt value together with the required shares for this setting.\r\n   b) provides only information regarding the client identity as the PBKDF and salt values cannot be realistically predicted. \r\n   \r\nIn case that the server detects that \"PBKDF and workload parameters\" or \"salt\" do not match or are empty, a hello retry message is sent specifying which salt value and which actual \"PBKDF + Workload parameter\" to use for the given client identity.\r\n\r\nIn case of the hello retry mechanism the client would then send a modified client hello which will include all required shares for the given PBKDF and salt set.\r\n\r\nWe should not allow any structure change in the client hello except for modifications regarding the \"PBKDF + Workload parameter\" and \"salt value\" set to use.\r\n\r\nIn practice this will result in a 3-message flow for applications which can predict all required information (e.g. PBKDF+Workload = fixed and salt = \"\") and in a 3 + 2 message flow otherwise.\r\n\r\nAs a result, for any augmented PAKE I'd include a \"salt\" value and a joint \"PBKDF+Workload\" code point in the PAKE-specific part of the payload and would allow for a hello-retry if \"PBKDF+Workload\" and \"salt\" value are the only parameter changed as a result of a \"hello retry\" from the server.",
          "createdAt": "2024-11-21T21:06:14Z",
          "updatedAt": "2024-11-21T21:06:14Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "With respect to the use-case of server databases where there are different PBKDF settings for different users, I believe that an out-of-band mechanism is just not practical. As we are able to implement all of the needed mechanisms within the existing TLS 1.3 architectures I am strongly opposed to mandate an additional OOB mechanism.\r\n\r\nInstead the way would be to allow for more flexible use of EAP within TLS 1.3, which (unlike the suggested HelloRetry mechanism) will likely end up with a compatibility nightmare and dozens of mutually incompatible EAP flavors.\r\n",
          "createdAt": "2024-11-21T21:28:33Z",
          "updatedAt": "2024-11-21T21:28:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "@BjoernMHaase what you are describing is in fact a tremendous amount of complexity on an otherwise simple protocol. We do not need to negotiate the use of PBKDF parameters any more than we need to negotiate the use of a context string in SPAKE2+: these are known by the application, and applications should be constructed to determine them before the connection starts. I am firmly opposed to specifying the use of HRR, or any retry mechanism, for a protocol that simply does not need it.",
          "createdAt": "2024-11-21T21:51:42Z",
          "updatedAt": "2024-11-21T21:51:42Z"
        },
        {
          "author": "FrankXL",
          "authorAssociation": "NONE",
          "body": "> @BjoernMHaase what you are describing is in fact a tremendous amount of complexity on an otherwise simple protocol. We do not need to negotiate the use of PBKDF parameters any more than we need to negotiate the use of a context string in SPAKE2+: these are known by the application, and applications should be constructed to determine them before the connection starts. I am firmly opposed to specifying the use of HRR, or any retry mechanism, for a protocol that simply does not need it.\r\n\r\nHi, Chris. A simple confusion, since TLS 1.3 already has sound HRR and retry mechanism, is there any problem directly reuse it for PAKE?",
          "createdAt": "2024-11-22T01:06:14Z",
          "updatedAt": "2024-11-22T01:06:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "> Hi, Chris. A simple confusion, since TLS 1.3 already has sound HRR and retry mechanism, is there any problem directly reuse it for PAKE?\r\n\r\nYes -- this draft does not negotiate the PAKE using the TLS 1.3 extensions (\"key_share\" and \"supported_groups\"). It uses its own extension, because using a PAKE is orthogonal to using a normal key exchange algorithm. (In other words, as of now, it's not the case that offering a PAKE is done via another \"key_share\" value.)\r\n\r\nBecause these are independent extensions, we don't get HRR \"for free.\" We would need to specify (a) how the PAKE extension relates to the primary key exchange mechanisms in TLS 1.3 and then (b) how it works in conjunction with HRR. This is nothing but added complexity, in my opinion, since any sort of retry behavior can be avoided through other out-of-band, application-dependent means.",
          "createdAt": "2024-11-22T13:47:50Z",
          "updatedAt": "2024-11-22T13:47:50Z"
        },
        {
          "author": "menonsamir",
          "authorAssociation": "COLLABORATOR",
          "body": "> In my opinion it is an actual use-case that the client actually might not always know beforehand which PBKDF to use. More specifically, the client might know which PBKDF to use but might not know which workload parametrization to actually use for a specific account.\r\n\r\n@BjoernMHaase As I said above, the client independently chose the PBKDF and associated parameters when generating the registration record. If you are asking how clients should remember their own choices, I think that is pretty clearly a client-internal and application-specific concern. Different applications are going to vary on how they do this, and the draft should not specify this, just as it does not specify registration.",
          "createdAt": "2024-11-22T18:21:33Z",
          "updatedAt": "2024-11-22T18:21:33Z"
        },
        {
          "author": "FrankXL",
          "authorAssociation": "NONE",
          "body": "> With respect to the use-case of server databases where there are different PBKDF settings for different users, I believe that an out-of-band mechanism is just not practical. As we are able to implement all of the needed mechanisms within the existing TLS 1.3 architectures I am strongly opposed to mandate an additional OOB mechanism.\r\n> \r\n> Instead the way would be to allow for more flexible use of EAP within TLS 1.3, which (unlike the suggested HelloRetry mechanism) will likely end up with a compatibility nightmare and dozens of mutually incompatible EAP flavors.\r\n\r\n@BjoernMHaase I share the same thought here. Since we are doing the PAKE in TLS, implementing the PAKE negotiation within the existing TLS 1.3 architectures should be no problem. What we need to do is to study and discuss carefully case by case the right way of doing it. As long as the requirement is valid and agreed by us, let's discuss the right way to implement it.",
          "createdAt": "2024-11-25T08:05:07Z",
          "updatedAt": "2024-11-25T08:05:33Z"
        },
        {
          "author": "FrankXL",
          "authorAssociation": "NONE",
          "body": "> > Hi, Chris. A simple confusion, since TLS 1.3 already has sound HRR and retry mechanism, is there any problem directly reuse it for PAKE?\r\n> \r\n> Yes -- this draft does not negotiate the PAKE using the TLS 1.3 extensions (\"key_share\" and \"supported_groups\"). It uses its own extension, because using a PAKE is orthogonal to using a normal key exchange algorithm. (In other words, as of now, it's not the case that offering a PAKE is done via another \"key_share\" value.)\r\n> \r\n> Because these are independent extensions, we don't get HRR \"for free.\" We would need to specify (a) how the PAKE extension relates to the primary key exchange mechanisms in TLS 1.3 and then (b) how it works in conjunction with HRR. This is nothing but added complexity, in my opinion, since any sort of retry behavior can be avoided through other out-of-band, application-dependent means.\r\n\r\n@chris-wood \r\n1. my PAKE in TLS draft is the same: \"does not negotiate the PAKE using the TLS 1.3 extensions (\"key_share\" and \"supported_groups\"). \";\r\n2. I believe our principle and implementation are similar, make PAKE negotiation being orthogonal to TLS negotiation (both extension messages and KDF process), only reuse and overlay on the TLS existing messages;\r\n3. Until we have more details, I don't see any new complexity brought by overlay PAKE HRR extension in existing TLS HRR message. Maybe you can clarify more details to help us understanding your concerns?",
          "createdAt": "2024-11-25T08:15:18Z",
          "updatedAt": "2024-11-25T08:15:18Z"
        },
        {
          "author": "BjoernMHaase",
          "authorAssociation": "NONE",
          "body": "Hi to all,\r\n\r\nMenosamir and Chris, while we all seem to be interrested to see PAKEs integrated in TLS as soon and as smoothly as possibly, I think that this approach will only succeed when we consider all of the relevant aspects. And one aspect is that different applications will be having different requirements.\r\n\r\nLet's possibly start with the aspects where we all seem to have consensus:\r\n\r\n- It seems that no one in this discussion stream here seems to suggest that we should seriously consider encryption of the client and server hello messages. I think we can leave this out here and refer to ECH or other technology, if actually needed.\r\n\r\nThe aspects where we don't seem to have consensus is the need of handshaking. You seem to assume that any application is using just one curve forever and one PBKDF function and one PBKDF function workload parameter and must not use a salt value (account specific) or pepper value (server- and/or application specific) for the PKDF. \r\n\r\nYou also seem to assume that you are able to store state on the client for memorizing data from a previous password registration. \r\n\r\nAlso in your setting you presume that the client seems to have a view of both, client and server identity strings.\r\n\r\nThe point that I am making is that these assumption will not work in practice for a large number of applications and in my opinion is also nothing what we should be suggesting for any application as this effectively will preclude any crypto-agility in the future.\r\n\r\nMy suggestion is that we should follow an approach that makes things as easy as possible (without additional complexity) for applications where the above assumptions hold. However the recommended method should be to add the necessary fields for the curve, the PBKDF+parametrization and a salt string, to any augmented PAKE flavor.\r\n\r\nYes this will result in some but quite limited complexity. The main price to pay that I identify will be that several code points will be needed inside the PAKE protocol section.\r\n\r\nMy suggestion would be to allocate a code-point for a joint PBKDF+workload parameter combination, one code point for the curve and a separate code point for a PAKE protocol variant.\r\n\r\nIn case that no negotiation is needed the message flow might look as follows\r\n\r\nClientHello:\r\nPAKE_protocolCode(ClientIdentity, {CurveCode1, PBKDF+WorkloadCode, saltStringToUseForPBKDF, Other_PAKE_SPECIFIC_ClientMSG_Content_Such_As_Blinded_DH_PublicShareForCurve1})\r\n\r\nServerHello:\r\nPAKE_protocolCode(ServerIdentity, CurveCode1, PBKDF+WorkloadCode, saltStringToUseForPBKDF, ClientIdentity, Other_PAKE_SPECIFIC_ServerMSG_Content_Such_As_Blinded_DH_PublicShareForCurve1)\r\n\r\nApplications might also choose to use an empty salt string or an application-specific \"pepper\" string that is shared by all servers. Also in the simple settings, I'd recommend to at least use an application-specific \"pepper\" value shared by all servers.\r\n\r\nThe most general approach would be, however that the client just specifies a list of supported PAKE protocols with a set of supported curves only and the client_identity field\r\n\r\nClientHello:\r\nPAKE_protocolCode(client_identity, {CurveCode1}, {CurveCode2}, {CurveCode3} )\r\n\r\nHelloRetry:\r\nPAKE_protocolCode(ServerIdentity, CurveCode2, PBKDF+WorkloadCode, saltStringToUseForPpkdfAndClientIdentity, ClientIdentity)\r\n\r\nSecondClientHello:\r\nPAKE_protocolCode(client_identity, {CurveCode2, PBKDF+WorkloadCode, saltStringToUseForPBKDF, saltStringToUseForPBKDF, Other_PAKE_SPECIFIC_ClientMSG_Content_Such_As_Blinded_DH_PublicShareForCurve2)\r\n\r\nServerHello:\r\nPAKE_protocolCode(ServerIdentity, CurveCode2, PBKDF+WorkloadCode, saltStringToUseForPBKDF, ClientIdentity, Other_PAKE_SPECIFIC_ServerMSG_Content_Such_As_Blinded_DH_PublicShareForCurve2)\r\n\r\n\r\nHere the server will communicate the chosen curve and PBKDF + salt values to use such that a state-less client unit (with only a human operator and the password to start with) will be obtaining all the required information for a retry for the ClientHello.\r\n\r\nFor the actual structure of the messages I also see the need to answer the following design question, what happens if we have several supported PAKE protocol variants in a TLS implementation. E.g. four protocols such as \"OPAQUE\"+\"CPACE\"+\"SPAKE2\"+\"SPAKE2+\". Should the protocols share the identity fields or should we make these PAKE-protocol specific.\r\n\r\nMy gut feeling is that we have better kept the client identity field inside the actual PAKE protocol's inner part and not outside as a common parameter to share for all PAKE protocols. E.g. there might be PAKE protocol use-cases which don't work at all with identity fields but only with passwords. \r\n\r\nThe important aspect might be that\r\n\r\n- With this approach we allow for crypto-agility\r\n- We don't make things more complex for applications which don't want ever to prepare crypto agility. Those may keep their 3-flow protocol forever.\r\n- We don't make any change in the current mechanisms for TLS (where there is already the need for a hello-retry round in relevant settings today)\r\n- We allow for stateless clients which don't store anything and only have access to a human user memorizing his name and password and nothing else. \r\n\r\n",
          "createdAt": "2024-11-25T20:43:11Z",
          "updatedAt": "2024-11-25T20:43:11Z"
        },
        {
          "author": "WeiGuo-hw",
          "authorAssociation": "NONE",
          "body": "@BjoernMHaase \r\n\r\n1. Is there some use-case where PAKEs don\u2019t work at all with identity fields but only with passwords?\r\n\r\n2. If the PBKDF function and parameters as well as the salt value don\u2019t need to be transferred from the server to the client, there are also two cases that need to be considered, similar to the standard TLS 1.3 key exchange.\r\n\r\nIn case that HelloRetryRequest does not occur the message flow might look as follows\r\n\r\nClientHello:\r\nPAKE_protocolCode(pake_algorithms={pake_algorithm1, pake_algorithm2, pake_algorithm3}, pake_share={client_identity, client_shares={pake_algorithm1, client_pake_share for pake_algorithm1}})\r\n\r\nServerHello:\r\nPAKE_protocolCode(pake_share={server_identity, server_share={pake_algorithm1, server_pake_share for pake_algorithm1}})\r\n\r\nIn case that HelloRetryRequest does occur the message flow might look as follows\r\n\r\nClientHello:\r\nPAKE_protocolCode(pake_algorithms={pake_algorithm1, pake_algorithm2, pake_algorithm3}, pake_share={client_identity, client_shares={pake_algorithm1, client_pake_share for pake_algorithm1}})\r\n\r\nHelloRetryRequest:\r\nPAKE_protocolCode(pake_share={pake_algorithm2})\r\n\r\nSecondClientHello:\r\nPAKE_protocolCode(pake_algorithms={pake_algorithm1, pake_algorithm2, pake_algorithm3}, pake_share={client_identity, client_shares={pake_algorithm2, client_pake_share for pake_algorithm2}})\r\n\r\nServerHello:\r\nPAKE_protocolCode(pake_share={server_identity, server_share=(pake_algorithm2, server_pake_share for pake_algorithm2)})\r\n\r\nIn the above HelloRetryRequest message, only one selected_pake_algorithm field is defined in this message\u2019s pake_share extension. When considering the transfer of the PBKDF function and parameters as well as the salt value, more fields need to be defined in the pake_share extension of HRR message, and these fields may be optional in some cases (for example, in the second case given above).",
          "createdAt": "2024-11-29T09:39:48Z",
          "updatedAt": "2024-11-29T09:39:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "body": "@BjoernMHaase:\r\n\r\n> My suggestion would be to allocate a code-point for a joint PBKDF+workload parameter combination, one code point for the curve and a separate code point for a PAKE protocol variant.\r\n\r\nWe do not need separate code points for the PAKE protocol and curve. These can -- and should -- be the same codepoint, e.g., \"SPAKE2+ with P-256, SHA-256, HKDF-SHA256, and HMAC-SHA256\" is one entry in the registry. There is no need to negotiate these things separately. \r\n\r\nThat leaves us with the discussion about PBKDF parameterization. As has already been mentioned, this is an application-specific choice, and something the server does not even need to know about. Applications which have default values can simply use them. Applications which want to support multiple values can do so in a variety of ways:\r\n\r\n1. Applications can attempt to establish TLS connections with their preferred PBKDF parameter values, retrying with alternative values if the connection fails. (In this variant, the application would need to encode which parameter set it used in the identity, e.g., \"client_identity = <real client identity> || <PBKDF parameter values>\" (or whatever). This is needed because the server searches for registrations based on (a) client identity, (b) server identity, and (c) PAKE algorithm. \r\n2. Applications can implement logic wherein the client asks the server, in some out-of-band way, \"hey, what parameter set should I use?\"\r\n\r\nThere are probably other ways to do this, too.\r\n\r\nGiven that it's possible with the draft currently specified, I see no reason to try and shove this logic into the handshake. Doing so does nothing but add complexity where it's demonstrably not needed.\r\n\r\nIf the current specification cannot work for a particular application scenario, please describe that scenario, and please explain why the specification does not work. ",
          "createdAt": "2024-12-03T15:51:45Z",
          "updatedAt": "2024-12-03T15:51:45Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOM83jm86h4Uvb",
      "title": "PAKE IDs MUST be sent in increasing order",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/issues/10",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This would avoid complicated code to parse the list of PAKE shares and check for duplicates.",
      "createdAt": "2024-12-03T20:16:49Z",
      "updatedAt": "2024-12-03T20:16:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOM83jm86jILH2",
      "title": "How does juggling multiple PAKE algorithms work?",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/issues/12",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If transitioning between PAKEs algorithms, a client may find itself needing to offer multiple PAKE shares. But this means computing the initial message for _each_ PAKE and sending all of them. This may be expensive for, e.g. PQ-sized options or just when there are many algorithms to support.\r\n\r\nFor key_share, we had this whole HelloRetryRequest dance. Do we need something similar here?",
      "createdAt": "2024-12-12T20:33:12Z",
      "updatedAt": "2024-12-12T20:33:12Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOM83jm85-RCkk",
      "title": "Cleanup based on discussions",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-10T20:02:55Z",
      "updatedAt": "2024-10-11T10:28:47Z",
      "baseRepository": "chris-wood/draft-bmw-tls-pake13",
      "baseRefName": "main",
      "baseRefOid": "1debde36975d78814b9c8bc0bd3f1cf6605ed895",
      "headRepository": "chris-wood/draft-bmw-tls-pake13",
      "headRefName": "caw/edits",
      "headRefOid": "171b12554de1babd31115d65c5a0644459e757aa",
      "closedAt": "2024-10-11T10:28:47Z",
      "mergedAt": "2024-10-11T10:28:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ce996c17c57ed0872bfc9f77ea2f3cd7abd68660"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOM83jm86Mw-Pz",
          "commit": {
            "abbreviatedOid": "0245cd4"
          },
          "author": "baumanl",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-11T00:07:20Z",
          "updatedAt": "2024-10-11T00:07:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOM83jm85-y2Qn",
      "title": "Cleanup",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "OWNER",
      "assignees": [
        "menonsamir",
        "baumanl"
      ],
      "labels": [],
      "body": "Mandate protocol simulation and fixup some other things.",
      "createdAt": "2024-10-16T09:00:50Z",
      "updatedAt": "2024-10-17T19:46:30Z",
      "baseRepository": "chris-wood/draft-bmw-tls-pake13",
      "baseRefName": "main",
      "baseRefOid": "7efdd7a622e45cf84b06b874db5beacf8d7bd6df",
      "headRepository": "chris-wood/draft-bmw-tls-pake13",
      "headRefName": "caw/cleanup",
      "headRefOid": "593af2ba9915666d42d968f4d14173bb451ecd27",
      "closedAt": "2024-10-17T19:46:30Z",
      "mergedAt": "2024-10-17T19:46:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0207b2f04d237f9fceca966615adfa0a48268de4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOM83jm86CFyGa",
      "title": "Factor out identities from PakeShare",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/pull/8",
      "state": "MERGED",
      "author": "baumanl",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Previously had the client and server identity in each PAKEShare in the client hello, but had a requirement that they were all the same (to prevent enumeration attacks). This change factors the identity out to the PAKEClientHello to eliminate the need to check that they are all the same.",
      "createdAt": "2024-11-15T20:49:17Z",
      "updatedAt": "2024-12-03T17:24:03Z",
      "baseRepository": "chris-wood/draft-bmw-tls-pake13",
      "baseRefName": "main",
      "baseRefOid": "0207b2f04d237f9fceca966615adfa0a48268de4",
      "headRepository": "chris-wood/draft-bmw-tls-pake13",
      "headRefName": "lbauman/identity",
      "headRefOid": "aa00a05f066d75cdb1b9baacb608ed993816133e",
      "closedAt": "2024-12-03T17:24:03Z",
      "mergedAt": "2024-12-03T17:24:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0b400a172b3b8ce1eec84d5790a4dc1d4cf63102"
      },
      "comments": [
        {
          "author": "baumanl",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben @bob-beck If you agree with this change we'd also like to update the boringssl implementation to match this change.",
          "createdAt": "2024-11-15T20:55:32Z",
          "updatedAt": "2024-11-15T20:55:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOM83jm86Tmhl3",
          "commit": {
            "abbreviatedOid": "aa00a05"
          },
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-03T17:23:58Z",
          "updatedAt": "2024-12-03T17:23:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOM83jm86CF6OY",
      "title": "update text around value used as input to TLS key sched",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/pull/9",
      "state": "MERGED",
      "author": "baumanl",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Text was inconsistent with diagram and implementation. The SPAKE2+ confirmation messages are not computed or involved in the protocol. Instead, K_Shared (which depends on the protocol transcript) is used as input to the ECDHE key schedule and the TLS finished messages are used in place of the SPAKE2+ confirmation messages.",
      "createdAt": "2024-11-15T21:12:13Z",
      "updatedAt": "2024-12-03T17:24:24Z",
      "baseRepository": "chris-wood/draft-bmw-tls-pake13",
      "baseRefName": "main",
      "baseRefOid": "0207b2f04d237f9fceca966615adfa0a48268de4",
      "headRepository": "chris-wood/draft-bmw-tls-pake13",
      "headRefName": "lbauman/key_sched",
      "headRefOid": "3bfcecc1da7099a49db9e3dc210b624045f298d2",
      "closedAt": "2024-12-03T17:24:24Z",
      "mergedAt": "2024-12-03T17:24:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "092f92ddbb1e598eca7477ede9f8152436b91f89"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOM83jm86TmhyD",
          "commit": {
            "abbreviatedOid": "3bfcecc"
          },
          "author": "chris-wood",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-03T17:24:20Z",
          "updatedAt": "2024-12-03T17:24:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOM83jm86D8g6K",
      "title": "Sort to simplify duplicate detection",
      "url": "https://github.com/chris-wood/draft-bmw-tls-pake13/pull/11",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #10 ",
      "createdAt": "2024-12-03T21:21:00Z",
      "updatedAt": "2024-12-04T17:19:43Z",
      "baseRepository": "chris-wood/draft-bmw-tls-pake13",
      "baseRefName": "main",
      "baseRefOid": "e32284368db47b9dd890e973443a87e1a7a30ac3",
      "headRepository": "chris-wood/draft-bmw-tls-pake13",
      "headRefName": "caw/sort",
      "headRefOid": "9c0f42615a4d3646a52bd6210ee7949b3b611295",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOM83jm86TyMZN",
          "commit": {
            "abbreviatedOid": "9c0f426"
          },
          "author": "baumanl",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-04T17:19:43Z",
          "updatedAt": "2024-12-04T17:19:43Z",
          "comments": []
        }
      ]
    }
  ]
}